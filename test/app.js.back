require('dotenv').config();
const express = require('express');
const { execSync, spawn } = require('child_process');
const fs = require('fs');
const os = require('os');
const axios = require('axios');

const app = express();
const PORT = process.env.APP_PORT || 30000; // ä½¿ç”¨serv00åˆ†é…çš„ç«¯å£
const HOSTNAME = os.hostname();
const USERNAME = os.userInfo().username;

// æœåŠ¡é…ç½®ï¼ˆé‡ç‚¹ä¿®æ”¹éƒ¨åˆ†ï¼‰
const services = [
  {
    name: 'Hysteria2',
    pattern: 'server config.yaml',
    startCmd: './web server config.yaml',
    logFile: 'hysteria.log'
  },
  {
    name: 's5',
    pattern: '.s5/s5 -c .s5/config.json',
    startCmd: '~/.s5/s5 -c ~/.s5/config.json',
    logFile: 's5.log'
  }
];

// Telegramé€šçŸ¥åŠŸèƒ½
async function sendAlert(message) {
  if (!process.env.BOT_TOKEN || !process.env.CHAT_ID) {
    console.log('Telegramé€šçŸ¥æœªé…ç½®');
    return;
  }

  try {
    await axios.post(`https://api.telegram.org/bot${process.env.BOT_TOKEN}/sendMessage`, {
      chat_id: process.env.CHAT_ID,
      text: `${message}\n\nðŸ–¥ï¸ æœåŠ¡å™¨: ${HOSTNAME}\nðŸ‘¤ è´¦æˆ·: ${USERNAME}`
    });
  } catch (error) {
    console.error('Telegramé€šçŸ¥å¤±è´¥:', error.message);
  }
}

// å¢žå¼ºåž‹è¿›ç¨‹æ£€æŸ¥
function checkProcess(service) {
  try {
    const output = execSync(
      `ps aux | grep '${service.pattern}' | grep -v grep | awk '{print $2}'`
    ).toString();
    return output.trim().length > 0;
  } catch (error) {
    return false;
  }
}

// æ™ºèƒ½æœåŠ¡é‡å¯
function restartService(service) {
  try {
    // æ¸…ç†æ—§è¿›ç¨‹
    execSync(`pkill -f "${service.pattern}"`);
    
    // å¯åŠ¨æ–°è¿›ç¨‹
    const logStream = fs.createWriteStream(service.logFile, { flags: 'a' });
    const [cmd, ...args] = service.startCmd.split(' ');
    const child = spawn(cmd, args, {
      detached: true,
      stdio: ['ignore', logStream, logStream]
    });
    child.unref();

    // éªŒè¯å¯åŠ¨
    setTimeout(() => {
      if (checkProcess(service)) {
        sendAlert(`âœ… ${service.name} å¯åŠ¨æˆåŠŸ\nPID: ${child.pid}`);
      } else {
        sendAlert(`âš ï¸ ${service.name} å¯åŠ¨å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥æ—¥å¿—`);
      }
    }, 3000);

    return true;
  } catch (error) {
    sendAlert(`âŒ ${service.name} é‡å¯å¤±è´¥\né”™è¯¯: ${error.message}`);
    return false;
  }
}

// è‡ªåŠ¨ç›‘æŽ§ç³»ç»Ÿ
let monitorInterval = null;
function startMonitor() {
  if (monitorInterval) return;

  monitorInterval = setInterval(() => {
    services.forEach(service => {
      if (!checkProcess(service)) {
        console.log(`[${new Date().toISOString()}] ${service.name} ç¦»çº¿`);
        sendAlert(`ðŸ”„ æ­£åœ¨é‡å¯ ${service.name}...`);
        restartService(service);
      }
    });
  }, 30000); // 30ç§’æ£€æµ‹é—´éš”

  console.log('ç›‘æŽ§ç³»ç»Ÿå·²å¯åŠ¨');
}

// çŠ¶æ€æ£€æŸ¥API
app.get('/status', (req, res) => {
  const status = services.map(service => ({
    name: service.name,
    status: checkProcess(service) ? 'åœ¨çº¿' : 'ç¦»çº¿',
    lastUpdate: new Date().toISOString()
  }));
  res.json(status);
});

// å¼ºåˆ¶é‡å¯ç«¯ç‚¹
app.get('/restart', (req, res) => {
  services.forEach(service => restartService(service));
  res.json({ 
    status: 'success',
    message: 'å·²è§¦å‘å…¨æœåŠ¡é‡å¯'
  });
});

// å¯åŠ¨æœåŠ¡
app.listen(PORT, 'localhost', () => {
  console.log(`ðŸŸ¢ æœåŠ¡è¿è¡Œä¸­ | ç«¯å£: ${PORT}`);
  sendAlert('ðŸš€ ä¿æ´»ç³»ç»Ÿå¯åŠ¨æˆåŠŸ');
  startMonitor();
});

// ä¼˜é›…å…³é—­å¤„ç†
process.on('SIGTERM', () => {
  console.log('æ­£åœ¨å…³é—­æœåŠ¡...');
  clearInterval(monitorInterval);
  services.forEach(service => {
    execSync(`pkill -f "${service.pattern}"`);
  });
  process.exit(0);
});
